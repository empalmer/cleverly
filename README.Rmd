---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%", 
  dpi = 300,
  fig.retina = 2
)
```

# cleverly

<!-- badges: start -->
<!-- badges: end -->

Cleverly stands for (Cl)ustering with (E)xternal (V)ariabl(e)s in (R) with (L)ongitudinal (Y)s. 


# Installation

You can install the development version of `cleverly` from [GitHub](https://github.com/) with:

```{r load package, echo = T, results = 'hide', message = F, warning = F}
# install.packages("pak")
pak::pak("empalmer/cleverly")
library(cleverly)
```

# Example usage: 
## Simulate example data (binary)

Simulate compositional count data with longitudinal independence structure. This code will simulate 20 samples across 12 responses, using a binary external variable. Default arguments to `simulation_data` simulate 3 baseline clusters with 4 members each. 

```{r sim_data}
set.seed(127)
sim <- simulation_data(n = 20,
                       K = 12,
                       user_var = 1000,
                       cor_str = "IND", 
                       Z_type = "binary")

Y <- sim$Y
Z <- sim$Z

true_cluster <- rep(1:3, each = 4)

head(Y)
head(Z)
```

$Y$ is a data frame of 12 counts with a column of time and a column of individual. Z is a vector of binary external variables. 


## Run algorithm: 

We now run the `cleverly` algorithm, specifying the commonly needed arguments. Here, we specify subject_ids = individual, as individual is the id column in Y. We could have alternately given a vector of IDs. Similarly for time. `cleverly` needs to select the ideal tuning parameter `psi` - so we give a range of `psi_min` to `psi_max`, and a number (`npsi`) to test (6). 

We set `cluster_index` to 0 because we want to cluster on the baseline values, i.e. when $Z = 0$. If we want to cluster on the slope value, i.e. the effect of $Z$, we would set `cluster_index` to 1. 

```{r run algorithm, cache = T}
res <- cleverly(Y = Y,
                Z = Z,
                subject_ids = individual,
                time = time,
                cluster_index = 0,
                cor_str = "IND",
                psi_min = 10,
                psi_max = 5000,
                npsi = 3) 
```

## Results

```{r}
names(res)
```



## Diagnostics: 

Since we know the true clusters, we can look at the Rand index, adjusted rand index, jaccard index, classification error rate, and number of clusters:


```{r}
get_cluster_diagnostics(res, true_cluster)$cluster_diagnostics
```

We selected the exact right clusters!

## Visualizations

Visualize the data + clusters 

```{r}
plot_clusters(res)
```

Alternatively, if we want to examine a single cluster: 

```{r}
plot_one_cluster(res, cluster_val = 1)
```


## Simulate example data (continuous, slope)

`cleverly` also works with continuous random variables, and can additionally cluster on the slope response: 

We first simulation data with a continuous external variable, stored in `rsim_cont`, and then run the algorithm.

```{r, echo = F}
sim_cont <- simulation_data(n = 20,
                        range_start = 5000,
                        range_end = 20000,
                        nknots = 3,
                        K = 12,
                        order = 3,
                        user_var = 1000,
                        cor_str = "CON-d",
                        Z_type = "continuous",
                        rho = 0.4,
                        prob1 = .5,
                        slope_fxns = list(
                          function(t) cos(2 * pi * t),
                          function(t) cos(2 * pi * t),
                          function(t) cos(2 * pi * t),
                          function(t) cos(2 * pi * t),
                          function(t) 2 * sin(pi * t) - 1,
                          function(t) 2 * sin(pi * t) - 1,
                          function(t) 2 * sin(pi * t) - 1,
                          function(t) 2 * sin(pi * t) - 1,
                          function(t) 2 - 2 * t,
                          function(t) 2 - 2 * t,
                          function(t) 2 - 2 * t,
                          function(t) 2 - 2 * t
                        ),
                        # Slope functions
                        baseline_fxns = list(
                          function(t) 2 - t,
                          function(t) 2 * sin(pi * t),
                          function(t) .5,
                          function(t) t^2,
                          function(t)  -.5 ,
                          function(t) 2 * t - 2,
                          function(t) t,
                          function(t) 2 - t,
                          function(t) 1,
                          function(t) -.75,
                          function(t) .75,
                          function(t) 2 * t))
```


```{r}

```


## Troubleshooting: 

### Poorly fit data

```{r, cache = T}
res <- cleverly(Y = Y,
                Z = Z,
                subject_ids = individual,
                time = time,
                cluster_index = 0,
                cor_str = "IND",
                gammas = c(1e4, 1e4),
                psi_min = 500,
                npsi = 1) 

plot_clusters(res)
```

The tuning parameter `gammas` can be specified, but it is usually fine to leave it at the default. If you see the overall fit seems bad (in this case underfit, because gamma is too large), it can be changed.

### Too small hyper parameter range

```{r}
res <- cleverly(Y = Y,
                Z = Z,
                subject_ids = individual,
                time = time,
                cluster_index = 0,
                cor_str = "IND",
                psi_min = 10,
                psi_max = 11,
                npsi = 3) 
```

We get a warning, increase the range between psi_min and psi_max, or increase npsi. 
# Algorithm details
