% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cleverly-package.R, R/cleverly.R
\name{cleverly}
\alias{cleverly}
\title{Cleverly: Main Function of the Package}
\usage{
cleverly(
  Y,
  Z,
  subject_ids,
  time,
  cluster_index = 0,
  cor_str = "IND",
  gammas = NULL,
  psi_min = 500,
  psi_max = 1500,
  npsi = 10,
  status_bar = F,
  parralel = FALSE,
  nworkers = 2,
  tau = 0.005,
  theta = 500,
  C = 100,
  d = 2,
  nknots = 3,
  order = 3,
  epsilon_b = 0.001,
  epsilon_r = 0.001,
  epsilon_d = 0.001,
  epsilon_2 = 0.001,
  run_min = 3,
  max_outer_iter = 30,
  max_admm_iter = 100,
  max_2_iter = 100,
  BIC_type = "unrefit",
  response_type = "counts"
)
}
\arguments{
\item{Y}{A data frame or matrix of count response variables. Each column should represent a response variable, and each row a subject-time observation. Must be ordered by time. Total number of rows is \eqn{M}. Make sure Y values are counts and are not transformed to RA or rarified. We recommend running \code{cleverly} using less than 50 response variables (columns), otherwise computational time is an issue.}

\item{Z}{A vector, data frame, or matrix containing external variables. These external variables must be measured on every subject at every time point. We recommend using no more than 2-3 external variables to ensure clustering is meaningful. Must have \eqn{M} rows and \eqn{L} columns. If \code{Z} is missing, the algorithm will default to the COMPARING approach (clustering without an external variable).}

\item{subject_ids}{A vector of subject identifiers (length \eqn{M}) or optionally column name/index if \code{Y} is a data frame.}

\item{time}{A numeric vector of time points (length \eqn{M}) or optionally a column name/index if \code{Y} is a data frame.}

\item{cluster_index}{index of \eqn{Z} for which external variable to cluster on. Usually 0 (baseline) or 1 (slope), but can be >1 if there are multiple external variables, or the external variable is categorical with more than 2 categories. Note: cleverly uses \code{model.matrix} on Z, so if you want to cluster on a categorical variable, you need to make sure the cluster index matches the corresponding category.}

\item{cor_str}{Correlation structure to use. One of \code{"IND"}, \code{"CON"}, \code{"AR1"}, \code{"CON-d"}, or \code{"AR1-d"}. Unless large covariance is expected, \code{"IND"} is likely sufficient (and the fastest option).}

\item{gammas}{A numeric vector of length \eqn{L + 1} (number of columns in \code{Z} plus one for the intercept). These control the smoothness of the B-splines. Defaults to 1 for all variables. Modify if there appears to be large over-fitting or under-fitting of the final curves.}

\item{psi_min}{Minimum \eqn{\psi} value (or the only value, if \code{npsi = 1}).}

\item{psi_max}{Maximum \eqn{\psi} value (ignored if \code{npsi = 1}).}

\item{npsi}{Number of \eqn{\psi} values to evaluate. If greater than 1, an equally spaced sequence from \code{psi_min} to \code{psi_max} is generated and the optimal value is selected via BIC.}

\item{parralel}{Logical; whether to use parallelization. Defaults to \code{FALSE}. If \code{TRUE}, uses \code{future::plan(future::multisession)}.}

\item{nworkers}{Number of workers to use if \code{parralel = TRUE}.}

\item{tau}{MCP parameter. Default is \code{0.005}.}

\item{theta}{ADMM parameter. Default is \code{500}.}

\item{C}{Constant controlling the Hessian update threshold. Default is \code{100}.}

\item{d}{Order of the finite difference matrix.}

\item{nknots}{Number of knots in the B-spline basis.}

\item{order}{Order of the B-spline basis.}

\item{epsilon_b}{Tolerance for convergence of Algorithm 1.}

\item{epsilon_r}{Tolerance for ADMM convergence (residual).}

\item{epsilon_d}{Tolerance for ADMM convergence (dual).}

\item{epsilon_2}{Tolerance for convergence of Algorithm 2.}

\item{run_min}{Minimum number of runs. By default, cleverly will exit if there are three iterations where the cluster membership does not change. Increase run_min to force cleverly to run for a certain number of iterations before exiting.}

\item{max_outer_iter}{Maximum number of iterations for the outer loop (Algorithm 1).}

\item{max_admm_iter}{Maximum number of iterations for the ADMM clustering step (Algorithm 3).}

\item{max_2_iter}{Maximum number of iterations for Algorithm 2 (per outer iteration).}

\item{BIC_type}{Choose the "best" psi using unrefit or refit betas. Options are \code{"refit"} or \code{"unrefit"}. Defaults to \code{"refit"}, which simulations show gives the best performance.}

\item{response_type}{Type of response variable. Currently only \code{"Counts"} is valid.}
}
\value{
A list with the following components:
\describe{
\item{clusters}{List of Final cluster assignments, which contatins "no" - number of clusters, "csize" - size of each cluster, and "membership" the cluster assignemnt for each response}
\item{possible_clusters}{Cluster assignments for all tested \eqn{\psi} values.}
\item{chosen_psi}{Optimal \eqn{\psi} value selected via BIC.}
\item{y_hat_init}{Data frame with columns time, Z, response, y_hat, and y (relative response), where yhat is the initial fitted values before penalization}
\item{y_hat}{Data frame with columns time, Z, response, y_hat, and y (relative response), where yhat is the final fitted values.}
\item{y_hat_baseline}{Data frame with columns time, Z, response, y_hat, and y (relative response), where yhat is the fit for Z = 0}
\item{y_hat_refit}{Data frame with columns time, Z, response, y_hat, and y (relative response), where yhat is the log linear fit for the entire cluster group}
}
}
\description{
Runs the Cleverly algorithm over a range of \eqn{\psi} values and selects the optimal one based on BIC.
}
\examples{
\dontrun{
result <- cleverly(
  Y = Y,
  Z = Z,
  subject_ids = subject_ids,
  time = time,
  cluster_index = 1, # Cluster on slope
  cor_str = "AR1", # Use AR1 correlation structure
  gammas = rep(1, ncol(my_covariates) + 1),
  psi_min = 100,
  psi_max = 1000,
  npsi = 5,
)
}
}
